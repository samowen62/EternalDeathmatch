<!doctype html>
<html>
  <head>
    <title>Sample Game</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font: 13px Helvetica, Arial; }
      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
      form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
      form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
      #messages { list-style-type: none; margin: 0; padding: 0; }
      #messages li { padding: 5px 10px; }
      #messages li:nth-child(odd) { background: #eee; }
    </style>
    <script src="jquery.js"></script>
    <script src="socket.js"></script>
  </head>
  <body>
    <ul id="messages"></ul>
    <form action="">
      <input id="m" autocomplete="off" /><button>Send</button>
    </form>
  </body>
  <script src="app.js"></script>
  <!--script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
  <script src="three.js"></script>
  <script src="three.min.js"></script>
  <script src="js/renderers/Projector.js"></script>
  <script src="js/renderers/CanvasRenderer.js"></script>
  <script src="js/libs/stats.min.js"></script>
<script src="http://code.jquery.com/jquery-1.11.1.js"></script>

<script>
  var socket = io();

  //reset these on window  resize
  var winHeight = $(window).height();   // returns height of browser viewport
  var winWidth = $(window).width();   // returns width of browser viewport
  var centX = winWidth / 2;
  var centY = winHeight / 2;
  var mouseSensitivity = 0.1;

  $('form').submit(function(){
    socket.emit('chat message', $('#m').val());
    $('#m').val('');
    return false;
  });

  socket.on('news', function (data) {
      console.log(data);
      socket.emit('my other event', { my: 'data' });
  });

  $("body").mousemove(function(e) {
    console.log(mouseSensitivity * (e.clientY - centY) / winWidth);
    pointed.applyAxisAngle (up, mouseSensitivity * (e.clientY - centY) / winWidth);
  });


  var container, stats;
      var camera, scene, renderer;
      //from currPos to view point
      var pointed = new THREE.Vector3( 1, 0, 0);
      var currPos = new THREE.Vector3( 1, 0, 0);
      var up = new THREE.Vector3( 0, 1, 0);
      var tmpVec = new THREE.Vector3();

      var step = 1;
      var speed = 1;

      init();
      animate();

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        var info = document.createElement( 'div' );
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> - orthographic view';
        container.appendChild( info );

        camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );
        camera.position.x = 200;
        camera.position.y = 100;
        camera.position.z = 200;

        scene = new THREE.Scene();

        // Grid

        var size = 500, step = 50;

        var geometry = new THREE.Geometry();

        for ( var i = - size; i <= size; i += step ) {

          geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
          geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

          geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
          geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

        }

        var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } );

        var line = new THREE.Line( geometry, material, THREE.LinePieces );
        scene.add( line );

        // Cubes

        var geometry = new THREE.BoxGeometry( 50, 50, 50 );
        var material = new THREE.MeshLambertMaterial( { color: 0xffffff, shading: THREE.FlatShading, overdraw: 0.5 } );

        for ( var i = 0; i < 100; i ++ ) {

          var cube = new THREE.Mesh( geometry, material );

          cube.scale.y = Math.floor( Math.random() * 2 + 1 );

          cube.position.x = Math.floor( ( Math.random() * 1000 - 500 ) / 50 ) * 50 + 25;
          cube.position.y = ( cube.scale.y * 50 ) / 2;
          cube.position.z = Math.floor( ( Math.random() * 1000 - 500 ) / 50 ) * 50 + 25;

          scene.add( cube );

        }

        // Lights

        var ambientLight = new THREE.AmbientLight( Math.random() * 0x10 );
        scene.add( ambientLight );

        var directionalLight = new THREE.DirectionalLight( Math.random() * 0xffffff );
        directionalLight.position.x = Math.random() - 0.5;
        directionalLight.position.y = Math.random() - 0.5;
        directionalLight.position.z = Math.random() - 0.5;
        directionalLight.position.normalize();
        scene.add( directionalLight );

        var directionalLight = new THREE.DirectionalLight( Math.random() * 0xffffff );
        directionalLight.position.x = Math.random() - 0.5;
        directionalLight.position.y = Math.random() - 0.5;
        directionalLight.position.z = Math.random() - 0.5;
        directionalLight.position.normalize();
        scene.add( directionalLight );

        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor( 0xf0f0f0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        //

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        camera.left = window.innerWidth / - 2;
        camera.right = window.innerWidth / 2;
        camera.top = window.innerHeight / 2;
        camera.bottom = window.innerHeight / - 2;

        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      //

      function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

      }

      var map = []; // Or you could call it "key"
      onkeydown = onkeyup = function(e){
          e = e || event; // to deal with IE
          map[e.keyCode] = e.type == 'keydown';
          console.log(e.which);
      }

     /* window.addEventListener('keydown', function(event) {
        var s = step * speed;
        //console.log(event.keyCode);
        console.log(pointed, currPos);
        switch(event.keyCode){
          case 87: //w
            currPos.add(pointed)
            break;
          case 65: //a
            tmpVec.crossVectors(up, pointed);
            currPos.add(tmpVec);
            break;
          case 83: //s
            currPos.sub(pointed)
            break;
          case 68: //d
            tmpVec.crossVectors(pointed, up);
            currPos.add(tmpVec);
            break;
          case 90: //z
            currPos.y += s;
            break;
          case 88: //x
            currPos.y -= s;
            break;

        }

      }, false);*/

      function render() {

        //var timer = Date.now() * 0.0001;

        //see if better way
        camera.position.copy(currPos);
      //  console.log(camera.position, currPos, lookAt);
        camera.lookAt(tmpVec.addVectors(pointed, currPos));
        /*camera.position.x = Math.cos( timer ) * 200;
        camera.position.z = Math.sin( timer ) * 200;
        camera.lookAt( scene.position );*/

        renderer.render( scene, camera );

      }
</script-->
</html>
